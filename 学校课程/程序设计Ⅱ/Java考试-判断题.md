1. Java语言中需要区分字母的大写小写
2. Java语言中，变量名可以用汉字表示
3. 一个数组只能储存一种类型的数据
4. 字节码文件是与平台无关的二进制码，执行时由解释器解释成本地机器码
5. 一个Java源文件中可以有多个类，但只能有一个类是public的
6. Java允许创建不规则数组，即Java多维数组中各行的列数可以不同
7. boolean型数据的值只有true和false
8. 在一个编辑器中编写好的Java应用程序，是扩展名为.java的文件
9. 语句 `System.out.println(4+8+"Hello,world!");`的输出结果是`12Hello,world!`
10. 用static修饰的变量是类变量（静态变量） 
11. 在Java程序中，可以使用private来修饰一个类
12. 如果一个成员变量被修饰为final的，就是常量，常量必须赋给初值，而且不能再发生变化
13. 有的类定义时可以不定义构造函数，但构造函数是必需的，因为没有定义构造函数时，Java会自动提供一个无参构造函数
14. 类及其属性、方法可以同时有一个以上的修饰符来修饰
15. 一个类的静态方法不可以访问该类的非静态成员变量
16. 在实例方法或构造器中，this用来引用当前对象，通过使用this可引用当前对象的任何成员
17. 构造函数名与类名相同，没有返回值
18. 类也是一种数据类型（type）
19. 静态变量是被同一个类的所有实例所共享的
20. 类可以有两种重要的成员：成员变量和方法，类还可以有一种成员：内部类
21. 一个类的非静态方法可以访问静态成员变量
22. 实例变量只能通过对象名访问，类变量既可以通过某个对象名也可以通过类名来访问
23. 引用一个类的属性或调用其方法，不一定以这个类的对象为前缀。
24. 如果一个类的声明中没有使用extends关键字，这个类被系统默认为是继承Object类
25. Object是Java中所有类的共同父类
26. 可以使用protected修饰符来防止方法和数据被不同包的非子类访问
27. 子类不继承父类的构造方法
28. 构造方法可以调用本类中重载的构造方法和它的父类的构造方法
29. 为了克服单继承的缺点，Java使用了接口，一个类可以实现多个接口
30. 接口中的方法默认是public abstract方法
31. 类在实现接口方法时必须给出方法体，并且一定要用public来修饰方法体
32. 一个Java源文件就是由类和接口组成的
33. 如果一个类声明实现一个接口，但没有实现接口中的所有方法，那么这个类必须是abstract类
34. 类在实现接口的方法时，必须显式地使用public修饰符
35. 一个类只能有一个父类，但一个接口可以有一个以上的父接口
36. 接口中的方法默认都是抽象的
37. 接口中的属性，都是静态常量
38. 所有异常不一定捕获
39. 一个try语句可以有多个catch语句与之对应
40. 异常也是一个对象
41. 用户可以自定义自己的异常类
42. 可以使用throw语句来抛出异常
43. 可以使用throws语句来指明方法有异常抛出
44. 当一个方法在运行过程中产生一个异常，则这个方法会终止，但是整个程序不一定终止运行
45. 程序运行时所产生的系统定义的异常将自动被抛出
46. String字符串在创建后不能被修改，但可以创建一个字符串来代替原来的字符串
47. 设String对象`s="Hello "`，运行语句`System.out.println(s.concat("world!"));`输出为`Hello world!`但是String对象s的内容依然是`Hello `
48. Java中数组的元素可以是简单数据类型也可是对象
49. 数组作为方法的参数时，必须加在数组名后加方括号
50. 数组中有length()这个方法，如`arr.length`表示数组arr中数组长度
51. Java语言中的数组元素下标总是从0开始，下标可以是整数或整型表达式
52. StringBuffer类是线程安全的，StringBuilder类是线程不安全的
53. 声明构造方法时，可以使用private访问修饰符 
54. 在`java.util.Set`接口的实现类`java.util.HashSet`所表示的集合中，元素是无序的并且不允许重复，因此不能利用索引位置访问元素。
55. 子类如果想使用父类的构造方法，必须在子类的构造方法中使用，并且必须使用关键字super来表示，而且super必须是子类构造方法中的头一条语句
56. 一个Java类只能有继承一个父类
57. 一个接口可以继承其他接口
58. 使用方法str.length( )可以获得字符串str长度，arr.length能获得数组arr的长度
59. 抽象方法必须在抽象类中，但是抽象类中的方法不一定是抽象方法
60. abstract类（抽象类）中定义的方法不一定是abstract方法（抽象方法）
61. Java中类和方法都允许嵌套定义
62. abstract不能与final同时修饰同一个类
63. 抽象类是不能实例化的
64. Java中的String类型是一种引用数据类型，不是基本数据类型
65. 在定义一个类的时候，如果类的成员被private所修饰，该成员不能在类的外部被直接访问
66. 一个异常处理中 finally语句块可以不出现，也可以出现一次
67. Java语言中的所有异常类都是java.lang.Throwable的子类
68. String对象和StringBuffer对象都是字符串类型，StringBuffer创建后的可以原地修改，String对象不可以
69. 在java.util.List接口的实现类java.util.ArrayList所表示的集合中，元素是有序的并且可以重复。该数据结构底层由数组来实现，能够精确地控制每个元素的插入位置，或者删除某个位置的元素，对元素的随机访问速度特别快。
70. Set集合是无序的，不可以包含重复的对象
71. static关键字可以修饰成员变量，但不能修饰局部变量
72. 在Java中用static关键字修饰的方法可以直接通过类名来调用
73. Java基本数据类型都有对应的封装类。封装类能保留其数值，还有很多用处
74. 任何一种类类型，都可以使用new关键字来创建对象
75. 子类在继承父类的时候，不会自动继承父类的成员
76. 类中定义了一个有参的构造方法，系统不会再无参的构造方法
77. this关键字不能访问父类的成员变量和成员方法
78. Java中，String类中的equals()方法比较的是对象的内容，而非对象的地址值
79. String类的`equals()`方法和`==`的作用是不一样
80. java.lang是Java语言的核心类库,系统都会自动加载该包
81. 对于abstract类，不能创建该类的对象
82. 如果在子类的构造方法中，没有使用关键字super调用父类的某个构造方法，那么默认有super();语句，即调用父类的不带参数的构造方法
83. 在定义一个类的时候，如果类的成员被private所修饰，该成员不能在类的外部被直接访问
84. 构造方法不可以被继承
85. 抽象方法必须定义在抽象类中，但是抽象类中的方法不一定是抽象方法
86. super调用父类构造方法的代码必须位于子类构造方法的第一行
87. Java中，import导包语句必须是程序的第一条语句，但不是可执行语句
88. Java中，package定义包语句必须是.java程序的第一条可执行语句，且一个.java只能有一条package语句
89. Java中，使用protected关键字修饰的、不同包下的无关类之间不能直接互相访问
90. public可以修饰类、类的成员方法、类的成员变量，但是不可以修饰方法中的局部变量
91. Java中，this(…)或super(…)的调用必须是构造器中的第一条语句
92. Java中，final修饰的类，不能被子类继承
93. ava中，final关键字修饰的变量，变为常量，只能被赋值1次
94. Java中，final关键字修饰的类成员方法，不能被子类重写
95. Java中，final关键字修饰的基本类型变量，其对象中的属性是不可以改变的
96. Java中，默认修饰符修饰的类或成员是不能跨包访问的
97. 抽象类不能实例化，它包含常量、变量、抽象方法和具体的方法
98. Java中，一个类实现一个接口时，除了抽象类，必须重写接口中的方法
99. Java中，抽象类和抽象方法必须用abstract关键字修饰
100. Java中，接口中可以定义非抽象方法